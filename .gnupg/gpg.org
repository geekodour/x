#+title: o lord, it be gpg

* Create
** Certificate/Master/Primary key [C]
When creating the cert key, we don't want it to expire as we'll store it elsewhere.
#+begin_src shell
gpg --quick-generate-key 'Hrishikesh Barman <hrishi@geekodour.org>' ed25519 cert never
set -l KEY_ID "8963 3907 AE52 C5B4 72A1  ABF3 CB46 502E A121 F97D" # certificate key FP
gpg --quick-add-uid $KEY_ID 'Hrishikesh Barman <oss@geekodour.org>'
gpg --quick-add-uid $KEY_ID 'Hrishikesh Barman <hi@geekodour.org>'
gpg --quick-add-uid $KEY_ID 'Hrishikesh Barman <gigs@geekodour.org>'
#+end_src
** Sub keys [S], [E], [A]
#+begin_src shell
gpg --quick-add-key $KEY_ID cv25519 encr # [E], ed25519 is a signing scheme not a curve
gpg --quick-add-key $KEY_ID ed25519 sign # [S]
#+end_src
* List
#+begin_src shell
gpg --list-keys
gpg --list-secret-keys
#+end_src
* Export
** Exporting certificate key for offline storage
#+begin_src shell :tangle no
gpg --export-secret-key $KEY_ID | paperkey --output-type raw | qrencode --8bit --output secret-key.qr.png
#+end_src
- Now make sure to print it and write the passphrase along w it. You can use [[https://wiki.archlinux.org/title/Paperkey#Encode_the_secret_key_as_QR_Code][zbarcam]] to restore it later. (You'll need the public key)
** Exporting public key
#+begin_src shell
gpg --output primary_public.gpg --export $KEY_ID # binary
gpg --armor --output primary_public.asc --export $KEY_ID # ascii armored
#+end_src
#+begin_src text
-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEZD4JehYJKwYBBAHaRw8BAQdA2DHPnXvhVtqDIU+VDb37asZCBw7tDhPdsYVH
/DqQGx20KEhyaXNoaWtlc2ggQmFybWFuIDxocmlzaGlAZ2Vla29kb3VyLm9yZz6I
kQQTFgoAOQIbAQQLCQgHBBUKCQgFFgIDAQACHgECF4AWIQSJYzkHrlLFtHKhq/PL
RlAuoSH5fQUCZD4PDQIZAQAKCRDLRlAuoSH5fQrJAP9DbiDp1UZOTO6bq+S38TdQ
DWIaGW+DdI9YH6olaiB9MgD/XqtcQVUZBDbIC+hVQRYyHwGUcg/g/ttBBPnLo30F
7wy0JUhyaXNoaWtlc2ggQmFybWFuIDxvc3NAZ2Vla29kb3VyLm9yZz6IjgQTFgoA
NhYhBIljOQeuUsW0cqGr88tGUC6hIfl9BQJkPhKAAhsBBAsJCAcEFQoJCAUWAgMB
AAIeAQIXgAAKCRDLRlAuoSH5fcOLAPsG9zaBKhUpSlxxxQ4Q4/1mnoD0NGD28xSf
flC6W0cLTwEAmyW3M7G0LUc8bfikdx8OLIfOByAar+8j2LM1S4CwPQK0JEhyaXNo
aWtlc2ggQmFybWFuIDxoaUBnZWVrb2RvdXIub3JnPoiOBBMWCgA2FiEEiWM5B65S
xbRyoavzy0ZQLqEh+X0FAmQ+EoACGwEECwkIBwQVCgkIBRYCAwEAAh4BAheAAAoJ
EMtGUC6hIfl9VMAA/0gRoMBMEeajKSAik56p9W0YG8Irx+g1hUCstPcWoTjSAQCV
8iZ24mvItJUHxpmzIshp8s1YPSwhXmnAur+rr1HeAbQmSHJpc2hpa2VzaCBCYXJt
YW4gPGdpZ3NAZ2Vla29kb3VyLm9yZz6IjgQTFgoANhYhBIljOQeuUsW0cqGr88tG
UC6hIfl9BQJkPhKAAhsBBAsJCAcEFQoJCAUWAgMBAAIeAQIXgAAKCRDLRlAuoSH5
fdq0AQCf6G669zF0l/rBGwgbEQAb7IWvf0ZYCYRZjnDA4U4WWgEAqbs/aVuJvvUS
gFHTXop/sjbNYZxvgVVmTS/QYZO7KAg=
=qAjV
-----END PGP PUBLIC KEY BLOCK-----
#+end_src
* Delete
#+begin_src shell
gpg --delete-key $KEY_ID # public key
gpg --delete-secret-key $KEY_ID # private key
gpg --delete-secret-and-public-key $KEY_ID # both
#+end_src
* Revocation
- *You cannot delete a key from a keyserver*, you can only revoke it. See [[https://askubuntu.com/questions/625696/lost-pgp-private-key-and-want-to-remove-it-from-keyserver-ubuntu-com][this]].
- It needs to be stored somewhere safe because if someone gets access to this certificate he can use it to make your key unusable.
#+begin_src shell
gpg --output [fp]_revoke.rev --gen-revoke [fp] # generate revoke cert, also generated automatically at creation time
gpg --import [fp]_revoke.rev
gpg --keyserver <key_server_url> --send-keys [fp]
#+end_src
* Restoring
#+begin_src shell
zbarimg -1 --raw -q -Sbinary secret-key.qr.png | paperkey --pubring public-key.gpg | gpg --import
#+end_src
- Once imported, you might have to add it to the =trustdb= using =gpg --edit-key=. See [[https://unix.stackexchange.com/questions/407062/gpg-list-keys-command-outputs-uid-unknown-after-importing-private-key-onto][this.]]
* Extend
#+begin_src shell
gpg --quick-set-expire [fp] <never/1y>
#+end_src
* Extra security
** Removing and Backing up cert key
- We will not keep the certificate key in our home directory, we will move it offline. sub keys can stay for now till we get a physical key.
- First step is to completely backup the =~/.gnupg= directory to a local drive like a thumb drive.
- Once that's done we do
  - ~gpg --with-keygrip --list-key <key_ID>~
  - keygrip: SHA-1 hash of the public key parameters expressed in a way depended on the algorithm.
  - =cd ~/.gnupg/private-keys-v1.d= and then delete the cert key from there based on the =keygrip=
- Then we also remove the revocation certificate for the =[C]= key as we backed that up already.
- So our system is clean of =[C]= now.
* Signing git commits
- git records the hash of the previous commit in each next commit's metadata, creating an unbreakable cryptographic chain of records.
- So if you sign the HEAD commit, you're essentially verifying [[https://gist.github.com/masak/2415865][entire branch history]].
- Um, generally a good practice to PGP-sign commits. e.g. without commit signing Alice can fake a commit to pretend that it was actually authored by Bob
** Signed tags
- PGP signed tags are just annotated tags(tag object) with the tag content wrapped with the PGP signature.
** Signed commits
- Same as signed tags, just that signing happens on the commit object
